## 데이터 시각화

### 데이터
- 피쳐의 개념
    - ‘특성’이나 ‘특징’이라는 의미
    - 모델을 구성하는 데 데이터가 가장 큰 영향을 줌
    - 모델은 함수 형태로 표현
- 데이터 테이블(data table) : 데이터를 테이블(표)로 표현한 것
- 데이터 인스턴스(data instance) : 하나의 데이터
    - 튜플(tuple)이라고도 부름
    - 엑셀에서의 한 줄 한 줄
- 데이터의 분류 : 연속형 데이터와 이산형 데이터
    - 연속형 데이터(continuous data) : 값이 끊어지지 않고 계속 연결되는 종류의 데이터로, 실수와 관련된 값
        온도, 자동차의 속도
        평균, 분산 등 통계적 기법 적용 가능
    - 이산형 데이터(discrete data) : 연속적 값이 아니라 분리해서 표현하는 데이터로, 일종의 라벨로 구분 가능
        우편번호(숫자로 표현), 성별(텍스트로 표현)
        텍스트 형태의 값도 숫자 형태로 바꾸어 수식의 입력에 할당
- 연속형 데이터와 이산형 데이터의 가장 큰 차이는 그 숫자의 의미가 스케일(scale)이 있는가 없는가이다
- 이산형 데이터의 분류 : 숫자형 데이터, 명목형 데이터, 서수형 데이터
    - 숫자형 데이터(numeric data) : 연속형 데이터. 정량적으로 측정 가능한 데이터 타입을 의미한다. 정수나 실수 값. 단위가 있으면 등간척도형(interval-scaled type), 데이터와 비율이 있으면 비율척도형(ratio-scaled type) 데이터이다.
    - 명목형 데이터(nominal data) : 카테고리로 분류 가능한 데이터 타입. 이산형 데이터의 일종이며 ‘명목척도’라고도 표현한다. 두 개의 카테고리로만 데이터가 분류된다면 이진형 데이터 타입
    - 서수형 타입(ordinal data) : 범주형 데이터의 일종이지만 데이터 간의 순서가 존재하는 데이터 타입. 음료수 병의 크기를 대/중/소로 나누는 것
- 데이터의 형식
    - 데이터를 호출하기 위해서는 데이터 테이블 형태로 저장될 수 있는 타입을 사용한다
    - 다양한 데이터 타입으로 데이터 테이블을 저장할 수 있다
    - 대표적으로 ‘csv(comma separate value)’ 또는 ‘xlsx’ 파일
    - 트리 형태로 저장되어 있는 ‘json’이나 ‘xml’
    - 파이썬에 특화된 데이터 저장 형태인 ‘pickle’
    - 큰 데이터를 저장하는 이진 데이터 형식인 ‘h5’

### Numpy
- 기계 학습에서는 파이썬의 기본 리스트로 충분하지 않다.
- 데이터를 처리할 때는 리스트와 리스트 간의 연산이 가능해야 하는데 파이썬의 기본 리스트는 이것을 지원하지 않기 때문이다.
- 연산 속도도 중요하기 때문에 데이터 과학자들은 기본 리스트 대신에 넘파이(Numpy)를 선호한다.
- 넘파이의 개념
    - 파이썬의 고성능 과학 계산용 라이브러리
    - 벡터나 행렬 같은 선형대수의 표현법을 코드로 처리
    - 사실상의 표준 라이브러리
    - 다차원 리스트나 크기가 큰 데이터 처리에 유리
- 파이썬을 위한 행렬(matrix) 라이브러리
- 특징
    - 과학적인 계산을 위해서 만들어진 형태
    - 정적 할당의 구성 방식으로 사용하기 위하여 만들어짐
    - 행렬 연산 특화
    - 일반 List에 비해 빠르고, 메모리를 효율적으로 사용
    - 속도가 빠르고 메모리 사용이 효율적
    - 데이터를 메모리에 할당하는 방식이 기존과 다름
    - 반복문을 사용하지 않음
    - 연산할 때 병렬로 처리
    - 함수를 한 번에 많은 요소에 적용
    - 반복문 없이 데이터 배열에 대한 처리를 지원하여 빠르고 편리
    - 선형대수와 관련된 다양한 기능을 제공
    - C, C++, 포트란 등의 언어와 통합이 가능
- 성능
    - 넘파이의 텐서 연산의 장점
        C와 유사한 형태로 메모리를 관리하면서 C와 같은 연산 속도로 계산할 수 있다
        메모리 구조상 요소들이 붙어있기 때문
        파이썬의 가장 큰 특징인 동적 타이핑을 포기했지만, C로 구현되어 있어 배열 연산에 있어 매우 큰 성능적 우위 확보
        대용량 배열 연산에서 넘파이가 사실상 표준으로 사용됨
    - 연결 연산처럼 여러 배열을 붙이는 연산에서는 일반적인 리스트에 비해 느림
        필요할 때마다 메모리 탐색 과정으로 새로운 공간을 잡아야 하기 때문
- 넘파이 배열(ndarray) : 넘파이에서 텐서 데이터를 다루는 객체
- 텐서(tensor) : 선형대수의 데이터 배열
    - 랭크(rank)에 따라 이름이 다름
- 배열 생성
    - np.array 함수 사용하여 배열 생성
        매개변수 1: 배열 정보
        매개변수 2: 넘파이 배열로 표현하려는 데이터 타입
    - Numpy 형식으로 배열의 원소를 입력할 때는 반드시 리스트 형식으로 입력
- 파이썬 리스트와 넘파이 배열의 차이점
    - 텐서 구조에 따라 배열 생성
        배열의 모든 구성 요소에 값이 존재해야 함
    - 동적 타이핑을 지원하지 않음
        하나의 데이터 타입만 사용
    - 데이터를 메모리에 연속적으로 나열
        각 값 메모리 크기가 동일
        검색이나 연산 속도가 리스트에 비해 훨씬 빠름
- 데이터 특징을 출력하는 요소(property)는 dtype과 shape
    - dtype은 넘파이 배열의 데이터 타입을 반환
    - shape는 넘파이 배열에서 객체(object)의 차 (dimension)에 대한 구성 정보를 반환
    - 최대차원 np.ndim
    - 원소개수 np.size
- 매개변수 dtype으로 넘파이 배열의 데이터 타입 지정
    - 변수가 사용하는 메모리 크기가 정해짐
    - dtype을 실수형인 float으로 지정한다면 모든 데이터가 실수형으로 저장
- itemsize 요소(property)로 넘파이 배열에서 각 요소가 차지하는 바이트(byte) 확인
        np.float64로 dtype을 선언하면 64비트, 즉 8바이트 차지
        np.float32로 dtype을 선언하면 32비트, 즉 4바이트 차지
- rehape
    - 배열을 원하는 모양으로 생성 및 변형
    - 반드시 전체 요소의 개수는 통일
    - -1을 사용하면 나머지 차원의 크기를 지정했을 때 전체 요소의 개수를 고려하여 마지막 차원이 자동으로 지정됨
- flatten 함수는 데이터 그대로 1차원으로 변경
    - 데이터의 개수는 그대로 존재
    - 배열의 구조만 변한다
- 인덱싱(indexing)
    - 리스트에 있는 값의 상대적인 주소(offset)로 값에 접근
    - 넘파이 배열의 인덱스 표현에는 ‘,’을 지원
        ‘[행][열]’ 또는 ‘[행,열]’ 형태
    - 3차원 텐서 이상은 shape에서 출력되는 랭크 순서대로 인덱싱에 접근
- 슬라이싱(slicing)
    - 인덱스를 사용하여 리스트 일부를 잘라내어 반환
    - 넘파이 배열은 행과 열을 나눠 슬라이싱 가능
    - 증가값(step) : 리스트에서 데이터의 요소를 호출할 때 데이터를 건너뛰면서 반환
        ‘[시작 인덱스:마지막 인덱스:증가값]’ 형태
        각 랭크에 있는 요소별로 모두 적용할 수 있음
- arange
    - range 함수와 같이 차례대로 값을 생성
    - ‘(시작 인덱스, 마지막 인덱스, 증가값)’으로 구성
    - range 함수와 달리 증가값에 실수형이 입력되어도 값을 생성할 수 있음
    - 소수점 값을 주기적으로 생성할 때 유용
- ones 함수
    - 1로만 구성된 넘파이 배열을 생성
    - 사전에 shape 값을 넣어서 원하는 크기의 넘파이 배열 생성
- zeros 함수
    - 0으로만 구성된 넘파이 배열을 생성
- empty 함수
    - 활용 가능한 메모리 공간 확보하여 반환
    - ones와 zeros는 먼저 shape의 크기만큼 메모리를 할당하고 그곳에 값을 채움
    - 해당 메모리 공간에 값이 남았을 경우 그 값을 함께 반환
    - empty는 메모리 초기화 않아 생성될 때마다 다른 값 반환
- 생성 시점에서 dtype을 지정해주면 해당 데이터 타입으로 배열 생성
- ones_like 함수
    - 기존 넘파이 배열과 같은 크기로 만들어 내용을 1로 채움
- zeros_like 함수
    - 기존 넘파이 배열과 같은 크기로 만들어 내용을 0으로 채움
- empty_like 함수
    - 기존 넘파이 배열과 같은 크기로 만들어 빈 상태로 만듦
- identity 함수
    - 단위행렬(i행렬)을 생성
    - 매개변수 n으로 n×n 단위행렬을 생성
- eye 함수
    - 시작점과 행렬 크기를 지정, 단위행렬 생성
    - N은 행의 개수, M은 열의 개수를 지정
    - k는 열의 값을 기준으로 시작 인덱스
- diag 함수
    - 행렬의 대각성분 값을 추출
- uniform 함수 : 균등분포 함수
    - ‘np.random.uniform(시작값, 끝값, 데이터개수)’
- normal 함수 : 정규분포 함수
    - ‘np.random.normal(평균값, 분산, 데이터개수)’
- 연산 함수(operation function)
    - 배열 내부 연산을 지원하는 함수
- 축(axis)
    - 배열의 랭크가 증가할 때마다 새로운 축이 추가되어 차원 증가
- sum 함수
    - 각 요소의 합을 반환
    - sum 함수를 랭크가 2 이상인 배열에 적용할 때 축으로 연산의 방향을 설정
- 연결 함수(concatenation functions)
    - 두 객체 간의 결합을 지원하는 함수
- vstack 함수
    - 배열을 수직으로 붙여 하나의 행렬을 생성
- hstack 함수
    - 배열을 수평으로 붙여 하나의 행렬을 생성
- concatenate 함수
    - 축을 고려하여 두 개의 배열을 결합
    - 스택(stack) 계열의 함수와 달리 생성될 배열과 소스가 되는 배열의 차원이 같아야 함
    - 두벡터를 결합하고 싶다면, 해당 벡터를 일단 2차원 배열 꼴로 변환 후 행렬로 나타내야 함
- 사칙연산 함수
    - 넘파이는 파이썬과 동일하게 배열 간 사칙연산 지원
        행렬과 행렬, 벡터와 백터 간 사칙연산이 가능
    - 같은 배열의 구조일 때 요소별 연산(element-wise operation)
        요소별 연산 : 두 배열의 구조가 동일할 경우 같은 인덱스 요소들끼리 연산
- 배열 간의 곱셈에서는 요소별 연산과 벡터의 내적(dot product) 연산 가능
    - 벡터의 내적 : 두 배열 간의 곱셈
    - 두 개의 행렬에서 첫 번째 행렬의 열 크기와 두 번째 행렬의 행 크기가 동일해야 함
    - m×n 행렬과 n×l 행렬, 벡터의 내적 연산하면 m×l의 행렬 생성
- dot 함수
    - 벡터의 내적 연산
- 브로드캐스팅 연산(broadcasting operations)
    - 하나의 행렬과 스칼라 값들 간의 연산이나 행렬과 벡터 간의 연산
        방송국의 전파가 퍼지듯 뒤에 있는 스칼라 값이 모든 요소에 퍼지듯이 연산
- 비교 연산
    - 연산 결과는 항상 불린형(boolean type)을 가진  배열로 추출
    - 브로드캐스팅 비교 연산
        하나의 스칼라 값과 벡터 간의 비교 연산은 벡터 내 전체 요소에 적용
    - 요소별 비교 연산
        두 개의 배열 간 배열의 구조(shape)가 동일한 경우
        같은 위치에 있는 요소들끼리 비교 연산
        [1 ＞ 2, 3 ＞ 1, 0 ＞ 7] 과 같이 연산이 실시된 후 이를 반환
- all 함수
    - 배열 내부의 모든 값이 참일 때는 True
    - 하나라도 참이 아닐 경우에는 False를 반환
    - and 조건을 전체 요소에 적용
- any 함수
    - 배열 내부의 값 중 하나라도 참일 때는 True
    - 모두 거짓일 경우 False를 반환
    - or 조건을 전체 요소에 적용
- where 함수
    - 배열이 불린형으로 이루어졌을 때 참인 값들의 인덱스를 반환
- argsort
    - 배열 내 값들을 작은 순서대로 인덱스를 반환
- argmax
    - 배열 내 값들 중 가장 큰 값의 인덱스를 반환
- argmin
    - 배열 내 값들 중 가장 작은 값의 인덱스를 반환
- 불린 인덱스(boolean index)
    - 배열에 있는 값들을 반환할 특정 조건을 불린형의 배열에 넣어서 추출
    - 인덱스에 들어가는 배열은 불린형이어야 함
    - 불린형 배열과 추출 대상이 되는 배열의 구조가 같아야 함
- 팬시 인덱스(fancy index)
    - 정수형 배열의 값을 사용하여 해당 정수의 인덱스에 위치한 값을 반환
    - 인덱스 항목에 넣을 배열은 정수로만 구성되어야 함
    - 정수 값의 범위는 대상이 되는 배열이 가지는 인덱스의 범위 내 대상이 되는 배열과 인덱스 배열의 구조(shape)가 같을 필요는 없음

### 판다스
- 판다스의 개념
    - 파이썬의 데이터 분석 라이브러리
        데이터 테이블(data table)을 다루는 도구
    - 기본적으로 넘파이를 사용
        판다스는 넘파이를 효율적으로 사용하기 위해 인덱싱, 연산, 전처리 등 다양한 함수 제공
- 데이터프레임(DataFrame)
    - 데이터 테이블 전체 객체
- 시리즈(Series)
    - 각 열 데이터를 다루는 객체
- 시리즈 객체
    - 일반적으로 하나의 피쳐 데이터를 포함하는 형태
    - 생성된 데이터프레임(DataFrame) 안에 포함될 수 있음
    - list, dict, ndarray 등 다양한 데이터 타입이 시리즈 객체 형태로 변환되기도 함
- 시리즈 객체를 생성하면 세 가지 요소(property) 생성
    - 데이터(data)
        기존 다른 객체처럼 값을 저장하는 요소
    - 인덱스(index)
        항상 0부터 시작하고, 숫자로만 할당하는 값
        시리즈 객체에서는 숫자, 문자열, 0 외의 값으로 시작하는 숫자, 순서가 일정하지 않은 숫자를 입력할 수도 있음
        시리즈 객체에서는 인덱스 값의 중복을 허용
    - 데이터 타입(data type)
        넘파이의 데이터 타입과 일치
        판다스는 넘파이의 래퍼(wrapper) 라이브러리
        넘파이의 모든 기능 지원하고 데이터 타입도 그대로 적용
- 시리즈 객체는 객체의 이름을 변경할 수 있음
    - 열의 이름을 지정해주는 방식
    - 인덱스 이름도 추가로 지정 가능
- 시리즈 객체 생성하기
    - 데이터프레임 객체를 먼저 생성하고 각 열에서 시리즈 객체를 뽑는 것이 일반적인 방법
    - 다양한 시퀀스형 데이터 타입으로 저장 가능
- 판다스의 모든 객체는 인덱스 값을 기준으로 생성
    - 기존 데이터에 인덱스 값을 추가하면 NaN 값이 출력됨
- 데이터프레임 객체
    - 데이터 테이블 전체를 지칭하는 객체
    - 넘파이 배열의 특성을 그대로 가짐
    - 인덱싱 : 열과 행 각각 사용하여 하나의 데이터에 접근
- 데이터프레임의 생성
    - ‘read_확장자’ 함수로 데이터 바로 로딩
        .csv나 .xlsx 등 스프레드시트형 확장자 파일에서 데이터 로딩
    - 데이터프레임을 직접 생성
        딕셔너리 타입 데이터에서 키(key)는 열 이름,  (value)은 시퀀스형 데이터 타입을 넣어 각 열의 데이터로 만듦
        데이터 생성시, 열 이름을 한정하면 해당 열만 추출
        데이터가 존재하지 않는 열을 추가하면 해당 열에는 NaN 값들 추가

### 판다스-DATA 추출
- 데이터 로딩
    - xlsx 형태 데이터를 호출
        openpyxl 모듈을 설치
        pip install openpyxl
        read_excel 함수로 엑셀 데이터 호출
- 데이터 추출(열 이름 사용)
    - head와 tail 함수 : 처음 n개 행이나 마지막 n개 행 호출
    - 열 이름을 리스트 형태로 넣어 호출
        가장 일반적인 호출 방법
        문자형 열 이름을 하나만 넣으면 값이 시리즈 객체로 반환됨
        열 이름을 여러 개 넣으면 데이터프레임 객체로 반환됨
- 데이터 추출(행 번호 사용)
    - 인덱스 번호로 호출
    - 기존의 리스트나 넘파이 배열(ndarray) 인덱싱과 동일
- 데이터 추출(행,열 모두사용)
    - 열 이름과 행 번호 함께 사용
    - 데이터의 일정 부분을 사각형 형태로 잘라냄
- loc 함수
    - 인덱스 이름과 열 이름으로 데이터 추출
    - 인덱스를 0부터 시작하는 숫자 아닌 다른 값으로 변경 가능
- iloc 함수
    - 인덱스 번호로만 데이터 호출
    - ‘index location’의 약자
- reset_index 함수로 새로운 인덱스 할당된 객체 생성
    - 인덱스 이름이나 인덱스 중 편한 방법을 사용
- drop 함수
    - 특정 열이나 행을 삭제한 객체를 반환

### 판다스-그룹별 집계
- 그룹별 집계(groupby)
    - 데이터로부터 동일한 객체를 가진 데이터만 따로 뽑아 기술통계 데이터를 추출
    - 엑셀의 피봇테이블(pivot table) 기능과 비슷
    - 예) A반 수학 점수의 원본 데이터(raw data)를 가지고 있을 때 해당 데이터에서
        같은 성별을 가진 학생들의 평균 점수를 구하거나
        50점 이상을 받은 학생의 수를 구함
    - groupby 명령어는 분할→적용→결합 과정을 거침
        분할(split) : 같은 종류의 데이터끼리 나누는 기능
        적용(apply) : 데이터 블록마다 sum, count, mean 등 연산 적용
        결합(combine) : 연산 함수가 적용된 각 블록들을 합침
- 멀티 인덱스 그룹별 집계
    - 한 개 이상의 열을 기준으로 그룹별 집계를 실행
        리스트를 사용하여 여러 개의 열 이름을 기준으로 넣으면 여러 열이 키 값이 되어 결과 출력
        계층적 인덱스(hierarchical index) 형태
- 멀티 인덱스
    - 한 개 이상의 열로 그룹별 집계 수행하면 여러 열이 모두 인덱스로 반환됨
- 그룹화된(grouped) 상태
    - 분할→적용→결합 중에서 분할까지만 이루어진 상태
- get_group 함수
    - 해당 키 값을 기준으로 분할된 데이터프레임 객체를 확인
- 집계(aggregation)
    - 요약된 통계 정보를 추출
    - agg 함수 : min, 넘파이 mean 등 기존 함수 그대로 적용
- 변환(transformation)
    - 해당 정보를 변환
    - 키 값별로 요약된 정보가 아닌 개별 데이터 변환 지원
    - 적용 시점에서는 그룹화된 상태의 값으로 적용
- 필터(filter)
    - 특정 조건으로 데이터를 검색
    - 주로 filter 함수 사용

### 판다스-병합과 연결
- 병합(merge)
    - 두 개의 데이터를 특정 기준한 기준을 가지고 하나로 통합하는 작업
- SQL에서는 조인(join)이라는 표현을 더 많이 사용
- 내부 조인(inner join)
    - 키 값을 기준으로 두 테이블에 모두 존재하는 키 값의 행끼리 병합
- 완전 조인(full join)
    - 두 개의 테이블에서 각각의 행을 병합. 두 테이블에서 동일한 키 값을 가진 행은 통합하고, 두 테이블 중 하나라도 키 값이 존재하지 않는다면 존재하는 쪽의 데이터만 남겨둠
- 왼쪽 조인(left join)
    - 왼쪽 테이블의 값을 기준으로 같은 키 값을 소유하고 있는 행을 병합하고, 오른쪽 테이블에 해당 키 값이 존재하지 않는다면 해당 행은 삭제
- 오른쪽 조인(right join)
    - 오른쪽 테이블의 값을 기준으로 같은 키 값을 소유하고 있는 행을 병합하고, 왼쪽 테이블에 해당 키 값이 존재하지 않는다면 해당 행은 삭제
- 내부 조인(inner join)
    - 가장 기본적인 조인
    - 집합으로 보면 양쪽의 교집합 데이터를 통합
- left_on과 right_on 매개변수
    - 왼쪽 테이블과 오른쪽 테이블의 키 값이 다른 경우 left_on과 right_on 매개변수를 사용하여 각 테이블 키 값을 입력
- 왼쪽 조인
    - 왼쪽 테이블을 기준으로 데이터를 병합
    - 오른쪽 테이블에 왼쪽 테이블에 있는 키 값이 존재하지 않는다면 NaN으로 출력
- 오른쪽 조인
    - 오른쪽 테이블 기준으로 데이터를 병합
- 완전 조인
    - 두 테이블의 합집합을 의미
        양쪽에 같은 키 값이 있는 데이터는 합치고 나머지는 NaN
- 인덱스에 의한 병합
    - 인덱스 값을 키 값으로 하여 두 테이블을 병합할 수 있음
    - 인덱스가 의미 있는 열로 지정되어 있거나, 두 데이터가 모두 순서대로 들어가 있는 경우에 사용
    - right_index나 left_index 매개변수
- 연결(concatenate)
    - 두 테이블을 그대로 붙임
    - 데이터의 스키마가 동일할 때 그대로 연결
    - 주로 세로로 데이터를 연결
        concat 함수 : 두 개의 서로 다른 테이블을 하나로 합침
        append 함수 : 기존 테이블 하나에 다른 테이블을 붙임
        append 함수는 파일을 한 개씩 합치기 때문에 두 개 이상의 데이터프레임을 합칠 때에는 concat 함수를 쓰는 것이 좋다.