print("one"=="one")
print("one"!="one")
print("one"<"two")
print("one">"two")
print("one"<"pne")
#영문자순서에서 o 다음이 t랑 p가 있기 때문에 더크다

print(ord("a"))
print(ord("A"))
#ord는 그문자의 숫자크기값을 알 수 있다.


#비트연산자
print(bin(10)) #10진수 10을 2진수로 표현
print(bin(2))
print(10&2) #&는 엔드연산자로 10은 1010 2는 0010으로 엔드연산하면 0010으로 2가 된다.
print(10|2) #|는 or연산자로 1010 0010을 or연산하면 1010으로 10이된다.
#비트연산자는 비트를 2진수로 바꿔서 연산하여 나온 값

print(bin(14))
print(bin(3))
print(14%3)
print(14|3)

#&가 |보다 우선순위이다

#^는 XOR(배타적논리합)으로 같으면0 다르면1

#~는 부정

print(bin(8))
print(bin(8<<1)) #왼쪽이동 : 8의 2진수를 왼쪽으로 증가이등
print(bin(8<<2))
print(bin(8>>2)) #오른쪽이동 : 8의 2진수를 오른쪽으로 감소이동

#비트연산자에서는 ~반전연산이 젤 우선순위(항이 하나이기때문에)


#대입연산자 =는 오른쪽 값을 왼쪽으로 넣는 것으로 젤마지막에 수행된다.


#ex) 3+4*=10 라고하면 +는 산술연산자이고 *=는 대입연산자이기때문에 +가 먼저 연산된다.


#비트연산하면서 추가로 비트수가 생기지 않는다. 4비트랑4비트끼리 연산하면 4비트이하의 결과가 나온다.


print("aa"<"ab")
print(ord("a"),ord("b"))
print("one"<"two")
print("oa"<"ob") #o는 동일하기때문에 그다음문자에서 a보다 b가 영문자순서상 뒤에위치함
#동일할 시 그 다음자리를 비교한다.



x="21"
print("1"<=x<="9")
#다음과 같은 문자는 크기를 판별할 때 21은 이십일이 아닌 이일이기이다.
#맨 앞의 숫자부터 순차적으로 크기를 판별한다
#21에서 2가 9보다 작기때문에 트루이다.
x="10"
print("1"<=x<="5")
#이는 10이 십이아닌 일영이기때문에 일영의 1이 5보다 작기때문에 트루가된다.


x="632410"
print("1"<=x[0]<="5")
#여기서 x[0]은 x의 인덱스번호상 젤 첫번째 숫자만을 의미함
#따라서 6은 범위안에 있지 않아 폴스이다.


#관계연산자에서 <= >= ==등은 =이 있다고해서 대입연산자가 아니다.






















